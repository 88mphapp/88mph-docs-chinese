{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction # This is the documentation of 88mph , an upfront stable interest lending protocol. You can find the source code of 88mph on GitHub . To learn about how and why 88mph can achieve upfront stable interest, check out How 88mph works .","title":"Introduction"},{"location":"#introduction","text":"This is the documentation of 88mph , an upfront stable interest lending protocol. You can find the source code of 88mph on GitHub . To learn about how and why 88mph can achieve upfront stable interest, check out How 88mph works .","title":"Introduction"},{"location":"howitworks/","text":"How 88mph works # High level overview # What exactly happens when you, say, deposit 100 DAI into 88mph for 1 year? Your 100 DAI is transferred to 88mph. 88mph returns part of the 100 DAI back to your wallet as the \"upfront interest\" (let's say 10 DAI). 88mph takes the remaining 90 DAI and lends it out on a lending protocol with variable interest rate (e.g. Compound), which will generate interest for the 1 year deposit period. Once the 1 year is over, you withdraw 100 DAI from 88mph. At first glance, this may seem extremely problematic. To begin with, how is this different from simply juggling your own money around? Why would it need to be its own protocol? Secondly, if Compound failed to generate 10 DAI of interest from the 90 DAI lent to it in 1 year, you can't guarantee that you can withdraw 100 DAI from 88mph. These objections are resolved by 88mph through pooling the deposits together. Pooling deposits means putting the deposited DAI into a single pool, from which users can withdraw a deposit once its deposit period is over. How would pooling help? Risk balancing : If Compound's interest rate rose after a deposit, the interest generated by the funds lent to Compound could be more than the upfront interest given to the user. This surplus would be able to balance out the deficit caused by deposits where the interest rate has dropped since deposit. This way, risk of insolvency is reduced for the users, and the stability of 88mph's interest rate is supported. Overlapping deposit periods : If an older deposit could not generate enought interest to cover the deficit caused by the upfront interest payment to the depositor, and its deposit period will be over soon, a newer deposit could temporarily solve the issue, since the funds of the newer deposit can cover the deficit when the old depositor withdraws. This alone obviously does not solve the deficit, since it would essentially be a Ponzi scheme, but combined with risk balancing and the volatility in Compound's interest rate it definitely helps with keeping the 88mph pool solvent. In addition to pooling, 88mph also algorithmically determine the offered upfront interest rate, such that the part of the deposit that is lent to Compound is expected to generate enough interest to cover the upfront interest paid to the user. This will be further discussed in Technical details . Deficit funding & Interest rate leverage-longing # Simply doing the above, though, would make 88mph a fairly risky product: if the interest rate on Compound and Aave drop to a very low value and stay there for a long time, deposits made when the interest rate was still high would not by themselves generate enough interest to cover the original upfront interest payouts, and neither would the deposits made after the rates dropped help with this situation. This would cause a pool-wide insolvency event, which is obviously bad. This is why 88mph also offers another mechanic called Deficit funding . Deficit funding allows someone to immediately fill up the deficit of one or more deposits using their own money, and in exchange they would receive the interest generated by those deposits. Given that each 88mph deposit would generate enough interest to cover its own deficit as long as the average interest rate during the deposit period stays above 75% of the initial value (see Technical details ), a deficit funder would earn a profit as long as the interest rate doesn't drop by more than 25%. Not only does deficit funding significantly reduces the risk of depositing into 88mph, it also provides a brand new financial product that allows users to long the interest rates of Compound and Aave . It's similar to some other products that allows people to long and short interest rates ( LSDai ), except 88mph's deficit funding provides a profit even if the interest rate drops (as long as it doesn't drop by more than 25%), and provides even more profits if the interst rate rises. It's like leverage-longing the interest rate! Interoperability through Non-fungible tokens (NFTs) # 88mph represents deposits and deficit fundings using ERC-721 standard non-fungible tokens. This means that users can transfer them between accounts, buy or sell them on exchanges, put wrappers around them to add more features, and more! The limit is your imagination. Some possible use cases: - Deposited a lot of money into 88mph, but suddenly need cash? And you still want your deposit to generate profit? Well, you can take out a loan on lending platforms like RocketNFT using your deposit NFT as collateral, and pay it back once you withdraw your deposit. Magic! - You can wrap the deficit funding NFT with an ERC20-like semi-fungible token to fund deposits fractionally. Technical details # This section will detail how 88mph determines the upfront interest rate offered to the user. Suppose that for a certain deposit, the deposit period is t seconds, the Compound interest rate at the time of deposit is r_0 per second, the deposit amount is D , and the offered upfront interest is \\gamma D . Also suppose that the amount of interest earned from Compound is linear with regards to time (non-compounding interest). Furthermore, let's suppose that we predict the average interest rate offered by Compound during the deposit period is mr_0 , where m \\gt 0 . Then, the condition for the interest earned from Compound to be at least as much as the upfront interest given to the user is: \\gamma D \\le (1 - \\gamma) D m r_0 t which simplifies to: \\gamma \\le \\frac{m r_0 t}{1 + m r_0 t} Suppose we choose \\gamma = \\frac{m r_0 t}{1 + m r_0 t} to be the (non-annualized) upfront interest rate. This means that the amount that's lent to Compound will be just enough to cover the upfront interest. If the average Compound interest rate actually turns out to be greater than m r_0 , then the deposit will provide a surplus; otherwise it will be in deficit. Therefore, m r_0 is the minimum average Compound interest rate during the deposit period such that won't cause a deficit. It should be clear that m acts as a parameter that we can adjust to represent how optimistic/pessimistic we are about the future Compound interest rate, as well as how risky the pool is. If m > 1 , you would be optimistic about future Compound interest rates; if m < 1 , you would be pessimistic; if m = 1 , you would be neutral. At 88mph, we have selected m = \\frac 3 4 , meaning that an individual deposit won't have a deficit as long as the average money market interest rate during the deposit period will be at least \\frac 3 4 of the current rate. What about compound interest, which is what Compound & Aave offer? Since earning compound interest rather than non-compound interest just means that the pool will earn more interest, it just makes 88mph more secure against the risk of deficit. To summarize, the upfront interest offered by 88mph for a deposit of D DAI for t seconds is upfrontInterest = \\frac{\\frac 3 4 r_0 t}{1 + \\frac 3 4 r_0 t} D","title":"How 88mph works"},{"location":"howitworks/#how-88mph-works","text":"","title":"How 88mph works"},{"location":"howitworks/#high-level-overview","text":"What exactly happens when you, say, deposit 100 DAI into 88mph for 1 year? Your 100 DAI is transferred to 88mph. 88mph returns part of the 100 DAI back to your wallet as the \"upfront interest\" (let's say 10 DAI). 88mph takes the remaining 90 DAI and lends it out on a lending protocol with variable interest rate (e.g. Compound), which will generate interest for the 1 year deposit period. Once the 1 year is over, you withdraw 100 DAI from 88mph. At first glance, this may seem extremely problematic. To begin with, how is this different from simply juggling your own money around? Why would it need to be its own protocol? Secondly, if Compound failed to generate 10 DAI of interest from the 90 DAI lent to it in 1 year, you can't guarantee that you can withdraw 100 DAI from 88mph. These objections are resolved by 88mph through pooling the deposits together. Pooling deposits means putting the deposited DAI into a single pool, from which users can withdraw a deposit once its deposit period is over. How would pooling help? Risk balancing : If Compound's interest rate rose after a deposit, the interest generated by the funds lent to Compound could be more than the upfront interest given to the user. This surplus would be able to balance out the deficit caused by deposits where the interest rate has dropped since deposit. This way, risk of insolvency is reduced for the users, and the stability of 88mph's interest rate is supported. Overlapping deposit periods : If an older deposit could not generate enought interest to cover the deficit caused by the upfront interest payment to the depositor, and its deposit period will be over soon, a newer deposit could temporarily solve the issue, since the funds of the newer deposit can cover the deficit when the old depositor withdraws. This alone obviously does not solve the deficit, since it would essentially be a Ponzi scheme, but combined with risk balancing and the volatility in Compound's interest rate it definitely helps with keeping the 88mph pool solvent. In addition to pooling, 88mph also algorithmically determine the offered upfront interest rate, such that the part of the deposit that is lent to Compound is expected to generate enough interest to cover the upfront interest paid to the user. This will be further discussed in Technical details .","title":"High level overview"},{"location":"howitworks/#deficit-funding-interest-rate-leverage-longing","text":"Simply doing the above, though, would make 88mph a fairly risky product: if the interest rate on Compound and Aave drop to a very low value and stay there for a long time, deposits made when the interest rate was still high would not by themselves generate enough interest to cover the original upfront interest payouts, and neither would the deposits made after the rates dropped help with this situation. This would cause a pool-wide insolvency event, which is obviously bad. This is why 88mph also offers another mechanic called Deficit funding . Deficit funding allows someone to immediately fill up the deficit of one or more deposits using their own money, and in exchange they would receive the interest generated by those deposits. Given that each 88mph deposit would generate enough interest to cover its own deficit as long as the average interest rate during the deposit period stays above 75% of the initial value (see Technical details ), a deficit funder would earn a profit as long as the interest rate doesn't drop by more than 25%. Not only does deficit funding significantly reduces the risk of depositing into 88mph, it also provides a brand new financial product that allows users to long the interest rates of Compound and Aave . It's similar to some other products that allows people to long and short interest rates ( LSDai ), except 88mph's deficit funding provides a profit even if the interest rate drops (as long as it doesn't drop by more than 25%), and provides even more profits if the interst rate rises. It's like leverage-longing the interest rate!","title":"Deficit funding &amp; Interest rate leverage-longing"},{"location":"howitworks/#interoperability-through-non-fungible-tokens-nfts","text":"88mph represents deposits and deficit fundings using ERC-721 standard non-fungible tokens. This means that users can transfer them between accounts, buy or sell them on exchanges, put wrappers around them to add more features, and more! The limit is your imagination. Some possible use cases: - Deposited a lot of money into 88mph, but suddenly need cash? And you still want your deposit to generate profit? Well, you can take out a loan on lending platforms like RocketNFT using your deposit NFT as collateral, and pay it back once you withdraw your deposit. Magic! - You can wrap the deficit funding NFT with an ERC20-like semi-fungible token to fund deposits fractionally.","title":"Interoperability through Non-fungible tokens (NFTs)"},{"location":"howitworks/#technical-details","text":"This section will detail how 88mph determines the upfront interest rate offered to the user. Suppose that for a certain deposit, the deposit period is t seconds, the Compound interest rate at the time of deposit is r_0 per second, the deposit amount is D , and the offered upfront interest is \\gamma D . Also suppose that the amount of interest earned from Compound is linear with regards to time (non-compounding interest). Furthermore, let's suppose that we predict the average interest rate offered by Compound during the deposit period is mr_0 , where m \\gt 0 . Then, the condition for the interest earned from Compound to be at least as much as the upfront interest given to the user is: \\gamma D \\le (1 - \\gamma) D m r_0 t which simplifies to: \\gamma \\le \\frac{m r_0 t}{1 + m r_0 t} Suppose we choose \\gamma = \\frac{m r_0 t}{1 + m r_0 t} to be the (non-annualized) upfront interest rate. This means that the amount that's lent to Compound will be just enough to cover the upfront interest. If the average Compound interest rate actually turns out to be greater than m r_0 , then the deposit will provide a surplus; otherwise it will be in deficit. Therefore, m r_0 is the minimum average Compound interest rate during the deposit period such that won't cause a deficit. It should be clear that m acts as a parameter that we can adjust to represent how optimistic/pessimistic we are about the future Compound interest rate, as well as how risky the pool is. If m > 1 , you would be optimistic about future Compound interest rates; if m < 1 , you would be pessimistic; if m = 1 , you would be neutral. At 88mph, we have selected m = \\frac 3 4 , meaning that an individual deposit won't have a deficit as long as the average money market interest rate during the deposit period will be at least \\frac 3 4 of the current rate. What about compound interest, which is what Compound & Aave offer? Since earning compound interest rather than non-compound interest just means that the pool will earn more interest, it just makes 88mph more secure against the risk of deficit. To summarize, the upfront interest offered by 88mph for a deposit of D DAI for t seconds is upfrontInterest = \\frac{\\frac 3 4 r_0 t}{1 + \\frac 3 4 r_0 t} D","title":"Technical details"},{"location":"smartcontract/","text":"Smart contract reference # The smart contract source code can be found on GitHub . Mainnet deployments # Aave Pool # DInterest : 0xdf907B483C7e7402555BCb1D8d3878AC3a38F07B FeeModel : 0xf1409a2f1F5f53e46BbAfd334311c80e675a410D AaveMarket : 0x5e53247b147D57fAf9825DAbe6e06AE90Bd70BA9 Compound Pool # DInterest : 0xeBcE73ED303eB97fA8060F276083444B9bBe63c1 FeeModel : 0xf1409a2f1F5f53e46BbAfd334311c80e675a410D CompoundERC20Market : 0xEa7827E66bd41aA0F57557CE3516644dbFb11eaF Compound Pool (Legacy) # DInterest : 0x9b226970cdeAdA0026aEd50D02E4A0dD37C92b6F FeeModel : 0xf1409a2f1F5f53e46BbAfd334311c80e675a410D CompoundERC20Market : 0xe7326dc7D136c6dF7A4056679A82aBd144631043 Architecture overview # 88mph consists of 5 smart contracts: DInterest : The main smart contract that users interact with. Handles depositing, withdrawing, and keeping track of deposits. Emits all of the events used in the subgraph. FeeModel : Determines the fee strategy of 88mph, as well as who receives the fees. MoneyMarket : A wrapper for interacting with money market protocols, and stores all of the user funds. Requires a different one for each money market protocol. As of now we have CompoundERC20Market and AaveMarket written. NFT : Two non-fungible ERC721 tokens, used for representing ownership of deposits and fundings. API reference # DInterest # State changing functions # function deposit(uint256 amount, uint256 maturationTimestamp) external # Creates a single deposit for the caller. amount : The amount of stablecoin to deposit. The caller should have already approved the contract to spend this much stablecoin before calling this function. Scaled by 10^{stablecoinDecimals} . maturationTimestamp : The Unix timestamp at and after which the deposit will be able to be withdrawn. In seconds. function withdraw(uint256 depositID) external # Withdraws a single deposit for the caller. The caller must own the deposit NFT with ID depositID . depositID : The index of the deposit to be withdrawn in the deposits array plus 1. function earlyWithdraw(uint256 depositID) external # Withdraws a single deposit for the caller, before the maturation timestamp. The caller needs to approve stablecoin to DInterest before calling, the amount is equal to deposits[depositID].initialDeficit . The caller must own the deposit NFT with ID depositID . depositID : The index of the deposit to be withdrawn in the deposits array plus 1. function multiDeposit(uint256[] calldata amountList, uint256[] calldata maturationTimestampList) external # Deposits multiple deposits for the caller. The values at each index in each array will be combined to create a single deposit. amountList : An array of the amounts of stablecoin to deposit. The caller should have already approved the contract to spend this much stablecoin before calling this function. Scaled by 10^{stablecoinDecimals} . maturationTimestampList : An array of the Unix timestamps at and after which the deposits will be able to be withdrawn. In seconds. function multiWithdraw(uint256[] calldata depositIDList) external # Withdraws multiple deposits for the caller. The caller must own the deposit NFTs with IDs in depositIDList . depositIDList : The indices of the deposits to be withdrawn in the deposits array plus 1. function multiEarlyWithdraw(uint256[] calldata depositIDList) external # Withdraws multiple deposits for the caller, before the maturation timestamp. The caller needs to approve stablecoin to DInterest before calling, the amount is equal to the sum of deposits[depositID].initialDeficit over all depositIDs in depositIDList . The caller must own the deposit NFTs with IDs in depositIDList . depositIDList : The indices of the deposits to be withdrawn in the deposits array plus 1. function fundAll() external # Allows the caller to fund all of the existing deficit of the 88mph pool. In exchange, the caller receives a funding NFT, and the interest generated by the deposits the caller funded will be sent to the owner of the NFT whenever a deposit they funded is withdrawn. Before calling this function, the caller must approve at least the deficit amount of stablecoin to the DInterest contract. This amount may be obtained using surplus() . To avoid the transaction being reverted, it is recommended to simply set the approval amount to 2^{256}-1 . function fundMultiple(uint256 toDepositID) external # Allows the caller to fund the deficit of multiple deposits. In exchange, the caller receives a funding NFT, and the interest generated by the deposits the caller funded will be sent to the owner of the NFT whenever a deposit they funded is withdrawn. Before calling this function, the caller must approve at least the deficit amount of stablecoin to the DInterest contract. This amount may be obtained using surplusOfDeposit() . To avoid the transaction being reverted, it is recommended to simply set the approval amount to 2^{256}-1 . toDepositID : Deposits with ID from (not including) lastFundedDepositID to (including) toDepositID will be funded. Read only functions # function getDeposit(uint256 depositID) external view returns (uint256 amount, uint256 maturationTimestamp, uint256 initialDeficit, uint256 initialMoneyMarketPrice, bool active) # Returns info about a user deposit. The owner of the deposit is whichever Ethereum account that owns the ERC721 deposit token with id depositID . Inputs # depositID : The index of the deposit in the deposits array. Returns # amount : The amount of the deposit, in stablecoins. Scaled by 10^{stablecoinDecimals} . maturationTimestamp : The Unix timestamp at and after which the deposit will be able to be withdrawn. In seconds. initialDeficit : The initial deficit caused by the deposit. Equals to the upfront interest paid plus the fee. initialMoneyMarketPrice : The value returned by moneyMarket.price() at the time of deposit. active : true if the deposit hasn't been withdrawn, false otherwise. function getFunding(uint256 fundingID) external view returns (uint256 fromDepositID, uint256 toDepositID, uint256 recordedFundedDepositAmount, uint256 recordedMoneyMarketPrice) # Returns info about a funding. The owner of the funding (and the account who will receive the interests) is whichever Ethereum account that owns the ERC721 funding token with id fundingID . Inputs # fundingID : The index of the funding in the fundingList array. Returns # fromDepositID : Deposits with ID from (not including) fromDepositID to (including) toDepositID have their deficits funded by this funding instance. toDepositID : Deposits with ID from (not including) fromDepositID to (including) toDepositID have their deficits funded by this funding instance. recordedFundedDepositAmount : The current total deposit amount that is generating interest for the owner of this funding instance, in stablecoins. Scaled by 10^{stablecoinDecimals} . recordedMoneyMarketPrice : The value returned by moneyMarket.price() at the time of the latest withdrawal of a deposit funded by this funding instance. If no funded deposit has been withdrawn yet, this value is equal to the monet market price at the time of the funding instance's creation. function UIRMultiplier() external view returns (uint256) # Returns the multiplier m used here . Scaled by 10^{18} . function MinDepositPeriod() external view returns (uint256) # Returns the minimum deposit period, in seconds. function MaxDepositAmount() external view returns (uint256) # Returns the maximum deposit amount for a single deposit in stablecoin . Scaled by 10^{stablecoinDecimals} . function totalDeposit() external view returns (uint256) # Returns the total deposited amount of stablecoin . Scaled by 10^{stablecoinDecimals} . function moneyMarket() external view returns (address) # Returns the address of MoneyMarket . function stablecoin() external view returns (address) # Returns the address of the stablecoin used. function feeModel() external view returns (address) # Returns the address of FeeModel . function depositNFT() external view returns (address) # Returns the address of the ERC721 deposit token. function fundingNFT() external view returns (address) # Returns the address of ERC721 funding token. function calculateUpfrontInterestRate(uint256 depositPeriodInSeconds) external view returns (uint256 upfrontInterestRate) # Returns the current upfront interest rate \\gamma used here . Inputs # depositPeriodInSeconds : The length of the deposit's deposit period, in seconds. function blocktime() external view returns (uint256) # Returns the average block time 88mph uses in its upfront interest rate calculation, in seconds. Scaled by 10^{18} . function surplus() external view returns (bool isNegative, uint256 surplusAmount) # Returns the surplus value of the pool over the owed deposits. Returns # isNegative : Whether the surplus is negative. A negative surplus means there's a deficit. surplusAmount : Amount of the pool's surplus, in stablecoins. Scaled by 10^{stablecoinDecimals} . function surplusOfDeposit(uint256 depositID) external view returns (bool isNegative, uint256 surplusAmount) # Returns the surplus value of a particular deposit. Does not include funding. Inputs # depositID : The index of the deposit to be withdrawn in the deposits array plus 1. Returns # isNegative : Whether the surplus is negative. A negative surplus means there's a deficit. surplusAmount : Amount of the pool's surplus, in stablecoins. Scaled by 10^{stablecoinDecimals} . function depositsLength() external view returns (uint256) # Returns the length of the deposits array. function fundingListLength() external view returns (address) # Returns the length of the fundingList array. function depositIsFunded(uint256 depositID) external view returns (bool) # Inputs # depositID : The index of the deposit to be withdrawn in the deposits array plus 1. Returns # Returns whether or not the deposit's deficit has been funded. function latestFundedDepositID() external view returns (uint256) # Returns the maximum ID among funded deposits. It can be assumed that all deposits with ID less than or equal to this value have been funded. function unfundedUserDepositAmount() external view returns (uint256) # Returns the deposited stablecoin amount whose deficit hasn't been funded. Scaled by 10^{stablecoinDecimals} . FeeModel # Read only functions # function getFee(uint256 _txAmount) external pure returns (uint256 _feeAmount) # Used for determining how much fee to charge from a transaction. Inputs # _txAmount : The amount of the transaction from which a fee will be taken. Returns # _feeAmount : The amount of the fee that will be taken from the transaction. function beneficiary() external view returns (address) # Returns the address who will receive the fees. MoneyMarket # State changing functions # function deposit(uint256 amount) external # Lends amount stablecoins to the underlying money market protocol. Inputs # amount : The amount of stablecoins to be deposited. function withdraw(uint256 amountInUnderlying) external # Withdraws amountInUnderlying stablecoins from the underlying money market protocol. Inputs # amountInUnderlying : The amount of stablecoins to be withdrawn. Read only functions # function supplyRatePerSecond(uint256 blocktime) external view returns (uint256) # Returns the current interest rate offered by the money market, per second. Scaled by 10^{18} . Inputs # blocktime : The average block time, in seconds. Scaled by 10^{18} . function totalValue() external view returns (uint256) # Returns the total value locked in the money market, in terms of the underlying stablecoin. Scaled by 10^{stablecoinDecimals} . function price() external view returns (uint256) # Returns an index that can be used to compute the interest generated by the money market over a period of time. Specifically, interestOverPeriod = depositValueAtBeginningOfPeriod \\times \\frac{priceAtEndOfPeriod}{priceAtBeginningOfPeriod} .","title":"Smart contract reference"},{"location":"smartcontract/#smart-contract-reference","text":"The smart contract source code can be found on GitHub .","title":"Smart contract reference"},{"location":"smartcontract/#mainnet-deployments","text":"","title":"Mainnet deployments"},{"location":"smartcontract/#aave-pool","text":"DInterest : 0xdf907B483C7e7402555BCb1D8d3878AC3a38F07B FeeModel : 0xf1409a2f1F5f53e46BbAfd334311c80e675a410D AaveMarket : 0x5e53247b147D57fAf9825DAbe6e06AE90Bd70BA9","title":"Aave Pool"},{"location":"smartcontract/#compound-pool","text":"DInterest : 0xeBcE73ED303eB97fA8060F276083444B9bBe63c1 FeeModel : 0xf1409a2f1F5f53e46BbAfd334311c80e675a410D CompoundERC20Market : 0xEa7827E66bd41aA0F57557CE3516644dbFb11eaF","title":"Compound Pool"},{"location":"smartcontract/#compound-pool-legacy","text":"DInterest : 0x9b226970cdeAdA0026aEd50D02E4A0dD37C92b6F FeeModel : 0xf1409a2f1F5f53e46BbAfd334311c80e675a410D CompoundERC20Market : 0xe7326dc7D136c6dF7A4056679A82aBd144631043","title":"Compound Pool (Legacy)"},{"location":"smartcontract/#architecture-overview","text":"88mph consists of 5 smart contracts: DInterest : The main smart contract that users interact with. Handles depositing, withdrawing, and keeping track of deposits. Emits all of the events used in the subgraph. FeeModel : Determines the fee strategy of 88mph, as well as who receives the fees. MoneyMarket : A wrapper for interacting with money market protocols, and stores all of the user funds. Requires a different one for each money market protocol. As of now we have CompoundERC20Market and AaveMarket written. NFT : Two non-fungible ERC721 tokens, used for representing ownership of deposits and fundings.","title":"Architecture overview"},{"location":"smartcontract/#api-reference","text":"","title":"API reference"},{"location":"smartcontract/#dinterest","text":"","title":"DInterest"},{"location":"smartcontract/#state-changing-functions","text":"","title":"State changing functions"},{"location":"smartcontract/#function-deposituint256-amount-uint256-maturationtimestamp-external","text":"Creates a single deposit for the caller. amount : The amount of stablecoin to deposit. The caller should have already approved the contract to spend this much stablecoin before calling this function. Scaled by 10^{stablecoinDecimals} . maturationTimestamp : The Unix timestamp at and after which the deposit will be able to be withdrawn. In seconds.","title":"function deposit(uint256 amount, uint256 maturationTimestamp) external"},{"location":"smartcontract/#function-withdrawuint256-depositid-external","text":"Withdraws a single deposit for the caller. The caller must own the deposit NFT with ID depositID . depositID : The index of the deposit to be withdrawn in the deposits array plus 1.","title":"function withdraw(uint256 depositID) external"},{"location":"smartcontract/#function-earlywithdrawuint256-depositid-external","text":"Withdraws a single deposit for the caller, before the maturation timestamp. The caller needs to approve stablecoin to DInterest before calling, the amount is equal to deposits[depositID].initialDeficit . The caller must own the deposit NFT with ID depositID . depositID : The index of the deposit to be withdrawn in the deposits array plus 1.","title":"function earlyWithdraw(uint256 depositID) external"},{"location":"smartcontract/#function-multideposituint256-calldata-amountlist-uint256-calldata-maturationtimestamplist-external","text":"Deposits multiple deposits for the caller. The values at each index in each array will be combined to create a single deposit. amountList : An array of the amounts of stablecoin to deposit. The caller should have already approved the contract to spend this much stablecoin before calling this function. Scaled by 10^{stablecoinDecimals} . maturationTimestampList : An array of the Unix timestamps at and after which the deposits will be able to be withdrawn. In seconds.","title":"function multiDeposit(uint256[] calldata amountList, uint256[] calldata maturationTimestampList) external"},{"location":"smartcontract/#function-multiwithdrawuint256-calldata-depositidlist-external","text":"Withdraws multiple deposits for the caller. The caller must own the deposit NFTs with IDs in depositIDList . depositIDList : The indices of the deposits to be withdrawn in the deposits array plus 1.","title":"function multiWithdraw(uint256[] calldata depositIDList) external"},{"location":"smartcontract/#function-multiearlywithdrawuint256-calldata-depositidlist-external","text":"Withdraws multiple deposits for the caller, before the maturation timestamp. The caller needs to approve stablecoin to DInterest before calling, the amount is equal to the sum of deposits[depositID].initialDeficit over all depositIDs in depositIDList . The caller must own the deposit NFTs with IDs in depositIDList . depositIDList : The indices of the deposits to be withdrawn in the deposits array plus 1.","title":"function multiEarlyWithdraw(uint256[] calldata depositIDList) external"},{"location":"smartcontract/#function-fundall-external","text":"Allows the caller to fund all of the existing deficit of the 88mph pool. In exchange, the caller receives a funding NFT, and the interest generated by the deposits the caller funded will be sent to the owner of the NFT whenever a deposit they funded is withdrawn. Before calling this function, the caller must approve at least the deficit amount of stablecoin to the DInterest contract. This amount may be obtained using surplus() . To avoid the transaction being reverted, it is recommended to simply set the approval amount to 2^{256}-1 .","title":"function fundAll() external"},{"location":"smartcontract/#function-fundmultipleuint256-todepositid-external","text":"Allows the caller to fund the deficit of multiple deposits. In exchange, the caller receives a funding NFT, and the interest generated by the deposits the caller funded will be sent to the owner of the NFT whenever a deposit they funded is withdrawn. Before calling this function, the caller must approve at least the deficit amount of stablecoin to the DInterest contract. This amount may be obtained using surplusOfDeposit() . To avoid the transaction being reverted, it is recommended to simply set the approval amount to 2^{256}-1 . toDepositID : Deposits with ID from (not including) lastFundedDepositID to (including) toDepositID will be funded.","title":"function fundMultiple(uint256 toDepositID) external"},{"location":"smartcontract/#read-only-functions","text":"","title":"Read only functions"},{"location":"smartcontract/#function-getdeposituint256-depositid-external-view-returns-uint256-amount-uint256-maturationtimestamp-uint256-initialdeficit-uint256-initialmoneymarketprice-bool-active","text":"Returns info about a user deposit. The owner of the deposit is whichever Ethereum account that owns the ERC721 deposit token with id depositID .","title":"function getDeposit(uint256 depositID) external view returns (uint256 amount, uint256 maturationTimestamp, uint256 initialDeficit, uint256 initialMoneyMarketPrice, bool active)"},{"location":"smartcontract/#inputs","text":"depositID : The index of the deposit in the deposits array.","title":"Inputs"},{"location":"smartcontract/#returns","text":"amount : The amount of the deposit, in stablecoins. Scaled by 10^{stablecoinDecimals} . maturationTimestamp : The Unix timestamp at and after which the deposit will be able to be withdrawn. In seconds. initialDeficit : The initial deficit caused by the deposit. Equals to the upfront interest paid plus the fee. initialMoneyMarketPrice : The value returned by moneyMarket.price() at the time of deposit. active : true if the deposit hasn't been withdrawn, false otherwise.","title":"Returns"},{"location":"smartcontract/#function-getfundinguint256-fundingid-external-view-returns-uint256-fromdepositid-uint256-todepositid-uint256-recordedfundeddepositamount-uint256-recordedmoneymarketprice","text":"Returns info about a funding. The owner of the funding (and the account who will receive the interests) is whichever Ethereum account that owns the ERC721 funding token with id fundingID .","title":"function getFunding(uint256 fundingID) external view returns (uint256 fromDepositID, uint256 toDepositID, uint256 recordedFundedDepositAmount, uint256 recordedMoneyMarketPrice)"},{"location":"smartcontract/#inputs_1","text":"fundingID : The index of the funding in the fundingList array.","title":"Inputs"},{"location":"smartcontract/#returns_1","text":"fromDepositID : Deposits with ID from (not including) fromDepositID to (including) toDepositID have their deficits funded by this funding instance. toDepositID : Deposits with ID from (not including) fromDepositID to (including) toDepositID have their deficits funded by this funding instance. recordedFundedDepositAmount : The current total deposit amount that is generating interest for the owner of this funding instance, in stablecoins. Scaled by 10^{stablecoinDecimals} . recordedMoneyMarketPrice : The value returned by moneyMarket.price() at the time of the latest withdrawal of a deposit funded by this funding instance. If no funded deposit has been withdrawn yet, this value is equal to the monet market price at the time of the funding instance's creation.","title":"Returns"},{"location":"smartcontract/#function-uirmultiplier-external-view-returns-uint256","text":"Returns the multiplier m used here . Scaled by 10^{18} .","title":"function UIRMultiplier() external view returns (uint256)"},{"location":"smartcontract/#function-mindepositperiod-external-view-returns-uint256","text":"Returns the minimum deposit period, in seconds.","title":"function MinDepositPeriod() external view returns (uint256)"},{"location":"smartcontract/#function-maxdepositamount-external-view-returns-uint256","text":"Returns the maximum deposit amount for a single deposit in stablecoin . Scaled by 10^{stablecoinDecimals} .","title":"function MaxDepositAmount() external view returns (uint256)"},{"location":"smartcontract/#function-totaldeposit-external-view-returns-uint256","text":"Returns the total deposited amount of stablecoin . Scaled by 10^{stablecoinDecimals} .","title":"function totalDeposit() external view returns (uint256)"},{"location":"smartcontract/#function-moneymarket-external-view-returns-address","text":"Returns the address of MoneyMarket .","title":"function moneyMarket() external view returns (address)"},{"location":"smartcontract/#function-stablecoin-external-view-returns-address","text":"Returns the address of the stablecoin used.","title":"function stablecoin() external view returns (address)"},{"location":"smartcontract/#function-feemodel-external-view-returns-address","text":"Returns the address of FeeModel .","title":"function feeModel() external view returns (address)"},{"location":"smartcontract/#function-depositnft-external-view-returns-address","text":"Returns the address of the ERC721 deposit token.","title":"function depositNFT() external view returns (address)"},{"location":"smartcontract/#function-fundingnft-external-view-returns-address","text":"Returns the address of ERC721 funding token.","title":"function fundingNFT() external view returns (address)"},{"location":"smartcontract/#function-calculateupfrontinterestrateuint256-depositperiodinseconds-external-view-returns-uint256-upfrontinterestrate","text":"Returns the current upfront interest rate \\gamma used here .","title":"function calculateUpfrontInterestRate(uint256 depositPeriodInSeconds) external view returns (uint256 upfrontInterestRate)"},{"location":"smartcontract/#inputs_2","text":"depositPeriodInSeconds : The length of the deposit's deposit period, in seconds.","title":"Inputs"},{"location":"smartcontract/#function-blocktime-external-view-returns-uint256","text":"Returns the average block time 88mph uses in its upfront interest rate calculation, in seconds. Scaled by 10^{18} .","title":"function blocktime() external view returns (uint256)"},{"location":"smartcontract/#function-surplus-external-view-returns-bool-isnegative-uint256-surplusamount","text":"Returns the surplus value of the pool over the owed deposits.","title":"function surplus() external view returns (bool isNegative, uint256 surplusAmount)"},{"location":"smartcontract/#returns_2","text":"isNegative : Whether the surplus is negative. A negative surplus means there's a deficit. surplusAmount : Amount of the pool's surplus, in stablecoins. Scaled by 10^{stablecoinDecimals} .","title":"Returns"},{"location":"smartcontract/#function-surplusofdeposituint256-depositid-external-view-returns-bool-isnegative-uint256-surplusamount","text":"Returns the surplus value of a particular deposit. Does not include funding.","title":"function surplusOfDeposit(uint256 depositID) external view returns (bool isNegative, uint256 surplusAmount)"},{"location":"smartcontract/#inputs_3","text":"depositID : The index of the deposit to be withdrawn in the deposits array plus 1.","title":"Inputs"},{"location":"smartcontract/#returns_3","text":"isNegative : Whether the surplus is negative. A negative surplus means there's a deficit. surplusAmount : Amount of the pool's surplus, in stablecoins. Scaled by 10^{stablecoinDecimals} .","title":"Returns"},{"location":"smartcontract/#function-depositslength-external-view-returns-uint256","text":"Returns the length of the deposits array.","title":"function depositsLength() external view returns (uint256)"},{"location":"smartcontract/#function-fundinglistlength-external-view-returns-address","text":"Returns the length of the fundingList array.","title":"function fundingListLength() external view returns (address)"},{"location":"smartcontract/#function-depositisfundeduint256-depositid-external-view-returns-bool","text":"","title":"function depositIsFunded(uint256 depositID) external view returns (bool)"},{"location":"smartcontract/#inputs_4","text":"depositID : The index of the deposit to be withdrawn in the deposits array plus 1.","title":"Inputs"},{"location":"smartcontract/#returns_4","text":"Returns whether or not the deposit's deficit has been funded.","title":"Returns"},{"location":"smartcontract/#function-latestfundeddepositid-external-view-returns-uint256","text":"Returns the maximum ID among funded deposits. It can be assumed that all deposits with ID less than or equal to this value have been funded.","title":"function latestFundedDepositID() external view returns (uint256)"},{"location":"smartcontract/#function-unfundeduserdepositamount-external-view-returns-uint256","text":"Returns the deposited stablecoin amount whose deficit hasn't been funded. Scaled by 10^{stablecoinDecimals} .","title":"function unfundedUserDepositAmount() external view returns (uint256)"},{"location":"smartcontract/#feemodel","text":"","title":"FeeModel"},{"location":"smartcontract/#read-only-functions_1","text":"","title":"Read only functions"},{"location":"smartcontract/#function-getfeeuint256-_txamount-external-pure-returns-uint256-_feeamount","text":"Used for determining how much fee to charge from a transaction.","title":"function getFee(uint256 _txAmount) external pure returns (uint256 _feeAmount)"},{"location":"smartcontract/#inputs_5","text":"_txAmount : The amount of the transaction from which a fee will be taken.","title":"Inputs"},{"location":"smartcontract/#returns_5","text":"_feeAmount : The amount of the fee that will be taken from the transaction.","title":"Returns"},{"location":"smartcontract/#function-beneficiary-external-view-returns-address","text":"Returns the address who will receive the fees.","title":"function beneficiary() external view returns (address)"},{"location":"smartcontract/#moneymarket","text":"","title":"MoneyMarket"},{"location":"smartcontract/#state-changing-functions_1","text":"","title":"State changing functions"},{"location":"smartcontract/#function-deposituint256-amount-external","text":"Lends amount stablecoins to the underlying money market protocol.","title":"function deposit(uint256 amount) external"},{"location":"smartcontract/#inputs_6","text":"amount : The amount of stablecoins to be deposited.","title":"Inputs"},{"location":"smartcontract/#function-withdrawuint256-amountinunderlying-external","text":"Withdraws amountInUnderlying stablecoins from the underlying money market protocol.","title":"function withdraw(uint256 amountInUnderlying) external"},{"location":"smartcontract/#inputs_7","text":"amountInUnderlying : The amount of stablecoins to be withdrawn.","title":"Inputs"},{"location":"smartcontract/#read-only-functions_2","text":"","title":"Read only functions"},{"location":"smartcontract/#function-supplyrateperseconduint256-blocktime-external-view-returns-uint256","text":"Returns the current interest rate offered by the money market, per second. Scaled by 10^{18} .","title":"function supplyRatePerSecond(uint256 blocktime) external view returns (uint256)"},{"location":"smartcontract/#inputs_8","text":"blocktime : The average block time, in seconds. Scaled by 10^{18} .","title":"Inputs"},{"location":"smartcontract/#function-totalvalue-external-view-returns-uint256","text":"Returns the total value locked in the money market, in terms of the underlying stablecoin. Scaled by 10^{stablecoinDecimals} .","title":"function totalValue() external view returns (uint256)"},{"location":"smartcontract/#function-price-external-view-returns-uint256","text":"Returns an index that can be used to compute the interest generated by the money market over a period of time. Specifically, interestOverPeriod = depositValueAtBeginningOfPeriod \\times \\frac{priceAtEndOfPeriod}{priceAtBeginningOfPeriod} .","title":"function price() external view returns (uint256)"}]}